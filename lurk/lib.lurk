!(load "pattern_impl.lurk")
!(load "term.lurk")
!(load "data_structures.lurk")
!(load "instantiate_in_place.lurk")

;; Auxiliar functions
!(defrec loop_to_ids_plugs 
   (lambda (n instructions stack ids plugs)
      (if (= n 0)
         (cons stack (cons instructions (cons ids (cons plugs nil))))
         (let ((id (car instructions))
               (instructions (cdr instructions))
               (temp (pop_stack_pattern stack))
               (pattern (car temp))
               (stack (cdr temp))
               )
               (loop_to_ids_plugs (- n 1) instructions stack (append id ids) (append pattern plugs))
         )
      )
   )
)


;; ExecutionPhase
!(def Gamma_phase 0)
!(def Claim_phase 1)
!(def Proof_phase 2)

;; Definition: read_u8_vec_aux(buffer, size) = (vec, buffer')
;; Use: (read_u8_vec_aux '(3 2 1 0) 2) => ((3 2) (1 0)
!(defrec read_u8_vec_aux
   (lambda (buffer size) 
           (if (eq buffer nil)
               nil
               (if (= size 0)
                   (cons nil (cons buffer nil))
                   (let ((ret (read_u8_vec_aux (cdr buffer) (- size 1))))
                        (cons 
                           (cons (car buffer) (car ret))
                           (cdr ret)))))))

;; Definition: read_u8_vec(buffer) = (vec, buffer')
;; Use: (read_u8_vec '(2 3 2 1 0)) => ((3 2) (1 0))
!(def read_u8_vec 
   (lambda (buffer) 
      (let ((size (car buffer)) 
            (buffer (cdr buffer)))
           (read_u8_vec_aux buffer size))))


;; execute_instructions

;; Metavars
;; Phi0 = MetaVar(0)
;; Phi1 = MetaVar(1)
;; Phi2 = MetaVar(2)
!(def phi0 (metavar_unconstrained 0))
!(def phi1 (metavar_unconstrained 1))
!(def phi2 (metavar_unconstrained 2))

;; Axioms
;; Prop1: phi0 => (phi1 => phi0)
;; Prop2: (phi0 => (phi1 => phi2)) => ((phi0 => phi1) => (phi0 => phi2))
;; Prop3: ((~(~phi0)) => phi0)
!(def prop1 (implies phi0 (implies phi1 phi0)))
!(def prop2 (implies (implies phi0 (implies phi1 phi2))
                     (implies (implies phi0 phi1)
                              (implies phi0 phi2))))
!(def prop3 (implies (negate (negate phi0)) phi0))

;; Quantifier: forall x. phi0
!(def quantifier (implies (esubst phi0 0 (evar 1)) (exists 0 phi0)))

;; Existence: exists x. phi0
!(def existence (exists 0 phi0))

;; Definition: switch_case(phase, stack, memory, claims, instructions) = (stack', memory', claims', instructions')
;; Use: (switch_case phase stack memory claims instructions)
;; Ex: (switch_case '(1) '(1) '(1) '(2 3 5 7))
!(def switch_case 
   (lambda (phase stack memory claims instructions)
      (let ((instr_u32 (car instructions))
            (instructions (cdr instructions)))
         (if (= instr_u32 2) ; Evar
            nil
            (if (= instr_u32 3) ; Svar
               nil
               (if (= instr_u32 4) ; Symbol
                  nil
                  (if (= instr_u32 5) ; Implication
                     (let ((pop1 (pop_stack_pattern stack))
                           (right (car pop1))
                           (stack (cdr pop1))
                           
                           (pop2 (pop_stack_pattern stack))
                           (left (car pop2))
                           (stack (cdr pop2))

                           (implication (implies left right))
                           )
                           (cons (push_stack (Pattern_ implication) stack) (cons memory (cons claims (cons instructions nil))))
                     )
                     (if (= instr_u32 6) ; Application
                        nil
                           (if (= instr_u32 7) ; Mu
                              nil
                              (if (= instr_u32 8) ; Exists
                                 nil
                                 (if (= instr_u32 9) ; MetaVar
                                       (let ((id (car instructions))
                                             (instructions (cdr instructions)))
                                          (if (eq id nil)
                                             nil ;; Error
                                             (let ((e_fresh (car (read_u8_vec instructions)))
                                                   (instructions (cdr instructions))
                                                   (s_fresh (car (read_u8_vec instructions)))
                                                   (instructions (cdr instructions))
                                                   (positive (car (read_u8_vec instructions)))
                                                   (instructions (cdr instructions))
                                                   (negative (car (read_u8_vec instructions)))
                                                   (instructions (cdr instructions))
                                                   (app_ctx_holes (car (read_u8_vec instructions)))
                                                   (instructions (cdr instructions))
                                                   
                                                   (metavar_pat (metavar id e_fresh s_fresh positive negative app_ctx_holes))
                                                   )

                                                   (if (eq (pattern_well_formed metavar_pat) nil)
                                                      nil ;; Error
                                                      (cons (push_stack (Pattern_ metavar_pat) stack) (cons memory (cons claims (cons instructions nil))))
                                                   )
                                             ) 
                                          ))
                                       (if (= instr_u32 10) ; ESubst
                                          nil
                                          (if (= instr_u32 11) ; SSubst
                                             nil
                                             (if (= instr_u32 12) ; Prop1
                                                (cons (push_stack (Proved_ prop1) stack) (cons memory (cons claims (cons instructions nil))))
                                                (if (= instr_u32 13) ; Prop2
                                                   (cons (push_stack (Proved_ prop2) stack) (cons memory (cons claims (cons instructions nil))))
                                                   (if (= instr_u32 14) ; Prop3
                                                      (cons (push_stack (Proved_ prop3) stack) (cons memory (cons claims (cons instructions nil))))
                                                      (if (= instr_u32 15) ; Quantifier
                                                         nil
                                                         (if (= instr_u32 19) ; Existence
                                                            nil
                                                            (if (= instr_u32 21) ; ModusPonens
                                                               (let ((temp (pop_stack_proved stack))
                                                                     (premise2 (car temp))
                                                                     (stack (cdr temp))
                                                                     
                                                                     (temp (pop_stack_proved stack))
                                                                     (premise1 (car temp))
                                                                     (stack (cdr temp))
                                                                     )
                                                                     (if (not (= (get :inst premise1) 5))
                                                                        nil
                                                                        (if (not (eq (get :left premise1) premise2))
                                                                           nil
                                                                           (cons(push_stack (Proved_ (get :right premise1)) stack) (cons memory (cons claims (cons instructions nil))))
                                                                        )
                                                                     )
                                                               )
                                                               (if (= instr_u32 22) ; Generalization
                                                                  nil
                                                                  (if (= instr_u32 26) ; Instantiate
                                                                     (let ((n (car instructions))
                                                                           (instructions (cdr instructions))
                                                                           (ids nil)
                                                                           (plugs nil)

                                                                           (temp (pop_stack stack)) ; TODO: inline this call
                                                                           (metaterm (car temp))
                                                                           (metaterm_pattern (get :pattern metaterm))
                                                                           (metaterm_type (get :type metaterm))
                                                                           (stack (cdr temp))

                                                                           (temp (loop_to_ids_plugs n instructions stack ids plugs))
                                                                           (stack (fst temp))
                                                                           (instructions (snd temp))
                                                                           (ids (trd temp))
                                                                           (plugs (fth temp))

                                                                           (metaterm (instantiate_internal metaterm_pattern ids plugs))
                                                                          )
                                                                          (if (eq metaterm_type 0)
                                                                              (cons (push_stack (Pattern_ metaterm) stack) (cons memory (cons claims (cons instructions nil))))
                                                                              (if (eq metaterm_type 1)
                                                                                 (cons (push_stack (Proved_ metaterm) stack) (cons memory (cons claims (cons instructions nil))))
                                                                                 nil ;; Error
                                                                              )
                                                                          )
                                                                     )
                                                                     (if (= instr_u32 27) ; Pop only the first item
                                                                        (let ((temp (pop_stack stack)) ; TODO: inline this call
                                                                              (stack (cdr temp))
                                                                              )
                                                                              (cons stack (cons memory (cons claims (cons instructions nil))))
                                                                        )

                                                                        (if (= instr_u32 28) ; Save
                                                                           (let ((term (car stack)))
                                                                              (cons stack (cons (push_memory term memory) (cons claims (cons instructions nil)))))
                                                                           (if (= instr_u32 29) ; Load
                                                                              (let ((index (car instructions))
                                                                                    (instructions (cdr instructions)))
                                                                                    (if (eq index nil)
                                                                                       nil ;; Error
                                                                                       (let ((term (nth index memory)))
                                                                                            (if (eq term nil)
                                                                                               nil ;; Error
                                                                                               (cons (push_stack term stack) (cons memory (cons claims (cons instructions nil))))
                                                                                            )
                                                                                       )
                                                                                    )
                                                                              )
                                                                              (if (= instr_u32 30) ; Publish
                                                                                 (if (eq phase 0)
                                                                                    (let ((temp (pop_stack_pattern stack))
                                                                                          (pattern (car temp))
                                                                                          (stack (cdr temp))
                                                                                          )
                                                                                          (cons stack (cons (push (Proved_ pattern) memory) (cons claims (cons instructions nil))))
                                                                                    )
                                                                                    (if (eq phase 1)
                                                                                          (let ((temp (pop_stack_pattern stack))
                                                                                                (pattern (car temp))
                                                                                                (stack (cdr temp))
                                                                                               )
                                                                                             (cons stack (cons memory (cons (push_claim pattern claims) (cons instructions nil))))
                                                                                          )
                                                                                          (if (eq phase 2)
                                                                                             (let ((temp (pop claims)) ; TODO: Should we add a check to see if the claims are empty?
                                                                                                   (pattern (car temp))
                                                                                                   (claims (cdr temp))
                                                                                                  )
                                                                                                  (if (eq pattern nil)
                                                                                                     nil ;; Error
                                                                                                     (let ((temp (pop_stack_proved stack)) ; TODO: Should we add a check to see if the stack is empty?
                                                                                                           (theorem (car temp))
                                                                                                           (stack (cdr temp))
                                                                                                          )
                                                                                                          (if (eq pattern theorem)
                                                                                                             (cons stack (cons memory (cons claims (cons instructions nil))))
                                                                                                             nil ;; Error
                                                                                                          )
                                                                                                     )
                                                                                                 )
                                                                                             )
                                                                                          )
                                                                                    )
                                                                                 )
                                                                                 (if (= instr_u32 137) ; CleanMetaVar
                                                                                    (let ((id (car instructions))
                                                                                          (instructions (cdr instructions)))
                                                                                          (if (eq id nil)
                                                                                             nil ;; Error
                                                                                             (let ((metavar_pat (metavar_unconstrained id)))
                                                                                                  (cons (push_stack (Pattern_ metavar_pat) stack) (cons memory (cons claims (cons instructions nil))))
                                                                                             )
                                                                                          )
                                                                                    )
                                                                                    (if (= instr_u32 138) ; NO_OP
                                                                                       (cons stack (cons memory (cons claims (cons '() nil))))
                                                                                       nil
                                                                                    )))))))))))))))))))))))))))

;; Definition: execute_instructions(buffer, stack, memory, claims, phase) = (stack', memory', claims', instructions')
!(def execute_instructions (lambda (buffer stack memory claims phase) 
   (map (switch_case phase) stack memory claims buffer)))

;; Definition: verify(gamma_buffer, claims_buffer, proof_buffer) = bool
!(def verify (lambda (gamma_buffer claims_buffer proof_buffer)
   (let ((stack Stack)
         (memory Memory)
         (claims Claims)
         (gamma (execute_instructions gamma_buffer stack memory claims Gamma_phase))
         (memory (snd gamma))
         (claim (execute_instructions claims_buffer stack memory claims Claim_phase))
         (memory (snd claim))
         (claims (trd claim))
         (proof (execute_instructions proof_buffer stack memory claims Proof_phase))
        )
        (if (eq (get :claims (trd proof)) nil)
           t
           nil
        )
   )
))
